rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Top-level studyRooms collection
    match /studyRooms/{roomId} {
      // Allow read of room document only if user is the room creator or a participant
      allow get: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid ||
        exists(/databases/$(database)/documents/studyRooms/$(roomId)/participants/$(request.auth.uid)));
      // Prevent wholesale overwrites of the room document from clients
      allow write: if false;

      // Messages subcollection - validate message shape and allow creation
      match /messages/{messageId} {
        // Only room creator or participants may read messages
        allow read: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid ||
          exists(/databases/$(database)/documents/studyRooms/$(roomId)/participants/$(request.auth.uid)));
        allow create: if (
          // Authenticated users may write messages under their uid
          (request.auth != null && request.resource.data.userId == request.auth.uid)
        allow create: if (
          // Authenticated users may write messages under their uid
          (request.auth != null && request.resource.data.userId == request.auth.uid)
          // OR unauthenticated clients using a short-lived anon id that starts with "anon-"
          || (request.auth == null && request.resource.data.userId is string && request.resource.data.userId.matches('^anon-.*'))
        ) &&
        // Basic validation of fields
        request.resource.data.text is string && request.resource.data.text.size() <= 2000 &&
        request.resource.data.user is string && request.resource.data.userId is string &&
        request.resource.data.createdAt is timestamp;

        // block updates and deletes from clients
        allow update, delete: if false;
      }

      // Voice signaling channel - ephemeral signaling documents (offer/answer/candidate)
      match /voice/{signalId} {
        // Only participants or room creator may create/read signaling docs
        allow read, create: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid || exists(/databases/$(database)/documents/studyRooms/$(roomId)/participants/$(request.auth.uid)));
        // Validate small signaling payloads and types
        allow create: if request.resource.data.from is string && request.resource.data.to is string && request.resource.data.type in ['offer','answer','candidate'] && request.resource.data.createdAt is timestamp && (request.resource.data.sdp is string || request.resource.data.candidate is map || request.resource.data.sdp == null);
        // No updates allowed; deletes are allowed (clients or server) to keep channel clean
        allow update: if false;
        allow delete: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid || resource.data.from == request.auth.uid);
      }

      // Whiteboard strokes - live drawing
      match /whiteboard/{docId} {
        match /items/{itemId} {
          allow read, create: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid || exists(/databases/$(database)/documents/studyRooms/$(roomId)/participants/$(request.auth.uid)));
          // Basic validation
          allow create: if request.resource.data.points is list && request.resource.data.color is string && request.resource.data.size is number && request.resource.data.createdAt is timestamp;
          // Only admin may delete strokes (used when clearing board)
          allow delete: if request.auth != null && get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid;
          allow update: if false;
        }
      }

  // Join requests - anyone may request to join
      match /joinRequests/{requestId} {
        // Only the room creator (admin) may read pending requests
        allow read: if request.auth != null && get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid;
        allow create: if request.resource.data.requesterId is string && request.resource.data.name is string && request.resource.data.requestedAt is timestamp && request.resource.data.status == 'pending';
        // Admin may update status
        allow update: if request.auth != null && get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid;
        allow delete: if false;
      }

      // Participants subcollection - track who's in the room
      match /participants/{participantId} {
        // Allow participants and creator to read participant list
        allow read: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid || exists(/databases/$(database)/documents/studyRooms/$(roomId)/participants/$(request.auth.uid)));
        // Only the room admin (createdBy) may create participant docs (approving joiners)
        allow create: if request.auth != null && get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid && request.resource.data.id is string && request.resource.data.name is string && request.resource.data.joinedAt is timestamp;
        // Participants may update their own lastActive if authenticated
        allow update: if request.auth != null && resource.data.id == request.auth.uid && (request.resource.data.lastActive is timestamp);
        // Admin or the participant themselves can delete the participant doc
        allow delete: if request.auth != null && (get(/databases/$(database)/documents/studyRooms/$(roomId)).data.createdBy == request.auth.uid || resource.data.id == request.auth.uid);
      }
    }
  }
}
